// Code generated by protoc-gen-gogo.
// source: flavortown.proto
// DO NOT EDIT!

/*
	Package flavortown is a generated protocol buffer package.

	It is generated from these files:
		flavortown.proto

	It has these top-level messages:
		Menu
		LineItem
		Lunch
		Nothing
*/
package flavortown

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import opsee_types "github.com/opsee/protobuf/opseeproto/types"
import opsee_types1 "github.com/opsee/protobuf/opseeproto/types"
import _ "github.com/gogo/protobuf/gogoproto"
import _ "github.com/opsee/protobuf/opseeproto"
import flavortown_dessert "github.com/opsee/protobuf/examples/dessert"

import bytes "bytes"

import github_com_graphql_go_graphql "github.com/graphql-go/graphql"
import github_com_opsee_protobuf_plugin_graphql_scalars "github.com/opsee/protobuf/plugin/graphql/scalars"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.GoGoProtoPackageIsVersion1

// The menu at Guy’s American Kitchen & Bar reflects his signature style of authentic and surprising flavors
type Menu struct {
	// These dishes are crafted with the heart and soul of hometown favorites and infused with Guy’s big, daring flavors
	Items []*LineItem `protobuf:"bytes,1,rep,name=items" json:"items,omitempty"`
}

func (m *Menu) Reset()                    { *m = Menu{} }
func (m *Menu) String() string            { return proto.CompactTextString(m) }
func (*Menu) ProtoMessage()               {}
func (*Menu) Descriptor() ([]byte, []int) { return fileDescriptorFlavortown, []int{0} }

func (m *Menu) GetItems() []*LineItem {
	if m != nil {
		return m.Items
	}
	return nil
}

// A line item representing a dish and price
type LineItem struct {
	// The menu dish, can either be lunch or dessert
	//
	// Types that are valid to be assigned to Dish:
	//	*LineItem_Lunch
	//	*LineItem_TastyDessert
	Dish isLineItem_Dish `protobuf_oneof:"dish"`
	// The price of the dish in cents
	PriceCents int32 `protobuf:"varint,2,opt,name=price_cents,json=priceCents,proto3" json:"price_cents,omitempty"`
	// A timestamp representing when the dish was added to the menu
	CreatedAt *opsee_types1.Timestamp `protobuf:"bytes,3,opt,name=created_at,json=createdAt" json:"created_at,omitempty"`
	// A timestamp representing when the dish was updated
	UpdatedAt *opsee_types1.Timestamp `protobuf:"bytes,4,opt,name=updated_at,json=updatedAt" json:"updated_at,omitempty"`
	// A list of nothing really
	Nothing *Nothing `protobuf:"bytes,5,opt,name=nothing" json:"nothing,omitempty"`
	// permission to eat?
	Sides *opsee_types.Permission `protobuf:"bytes,6,opt,name=sides" json:"sides,omitempty"`
}

func (m *LineItem) Reset()                    { *m = LineItem{} }
func (m *LineItem) String() string            { return proto.CompactTextString(m) }
func (*LineItem) ProtoMessage()               {}
func (*LineItem) Descriptor() ([]byte, []int) { return fileDescriptorFlavortown, []int{1} }

type isLineItem_Dish interface {
	isLineItem_Dish()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type LineItem_Lunch struct {
	Lunch *Lunch `protobuf:"bytes,100,opt,name=lunch,oneof"`
}
type LineItem_TastyDessert struct {
	TastyDessert *flavortown_dessert.Dessert `protobuf:"bytes,101,opt,name=tasty_dessert,json=tastyDessert,oneof"`
}

func (*LineItem_Lunch) isLineItem_Dish()        {}
func (*LineItem_TastyDessert) isLineItem_Dish() {}

func (m *LineItem) GetDish() isLineItem_Dish {
	if m != nil {
		return m.Dish
	}
	return nil
}

func (m *LineItem) GetLunch() *Lunch {
	if x, ok := m.GetDish().(*LineItem_Lunch); ok {
		return x.Lunch
	}
	return nil
}

func (m *LineItem) GetTastyDessert() *flavortown_dessert.Dessert {
	if x, ok := m.GetDish().(*LineItem_TastyDessert); ok {
		return x.TastyDessert
	}
	return nil
}

func (m *LineItem) GetCreatedAt() *opsee_types1.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *LineItem) GetUpdatedAt() *opsee_types1.Timestamp {
	if m != nil {
		return m.UpdatedAt
	}
	return nil
}

func (m *LineItem) GetNothing() *Nothing {
	if m != nil {
		return m.Nothing
	}
	return nil
}

func (m *LineItem) GetSides() *opsee_types.Permission {
	if m != nil {
		return m.Sides
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*LineItem) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _LineItem_OneofMarshaler, _LineItem_OneofUnmarshaler, _LineItem_OneofSizer, []interface{}{
		(*LineItem_Lunch)(nil),
		(*LineItem_TastyDessert)(nil),
	}
}

func _LineItem_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*LineItem)
	// dish
	switch x := m.Dish.(type) {
	case *LineItem_Lunch:
		_ = b.EncodeVarint(100<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Lunch); err != nil {
			return err
		}
	case *LineItem_TastyDessert:
		_ = b.EncodeVarint(101<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TastyDessert); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("LineItem.Dish has unexpected type %T", x)
	}
	return nil
}

func _LineItem_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*LineItem)
	switch tag {
	case 100: // dish.lunch
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Lunch)
		err := b.DecodeMessage(msg)
		m.Dish = &LineItem_Lunch{msg}
		return true, err
	case 101: // dish.tasty_dessert
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(flavortown_dessert.Dessert)
		err := b.DecodeMessage(msg)
		m.Dish = &LineItem_TastyDessert{msg}
		return true, err
	default:
		return false, nil
	}
}

func _LineItem_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*LineItem)
	// dish
	switch x := m.Dish.(type) {
	case *LineItem_Lunch:
		s := proto.Size(x.Lunch)
		n += proto.SizeVarint(100<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *LineItem_TastyDessert:
		s := proto.Size(x.TastyDessert)
		n += proto.SizeVarint(101<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// A delicious lunch dish on the menu
type Lunch struct {
	// The name of the dish
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The description of the dish
	Description []byte `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// a wild map. lunch tags? i guess
	Tags map[string]string `protobuf:"bytes,3,rep,name=tags" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Lunch) Reset()                    { *m = Lunch{} }
func (m *Lunch) String() string            { return proto.CompactTextString(m) }
func (*Lunch) ProtoMessage()               {}
func (*Lunch) Descriptor() ([]byte, []int) { return fileDescriptorFlavortown, []int{2} }

func (m *Lunch) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

// confusion
type Nothing struct {
	// the void
	Void string `protobuf:"bytes,1,opt,name=void,proto3" json:"void,omitempty"`
}

func (m *Nothing) Reset()                    { *m = Nothing{} }
func (m *Nothing) String() string            { return proto.CompactTextString(m) }
func (*Nothing) ProtoMessage()               {}
func (*Nothing) Descriptor() ([]byte, []int) { return fileDescriptorFlavortown, []int{3} }

func init() {
	proto.RegisterType((*Menu)(nil), "flavortown.Menu")
	proto.RegisterType((*LineItem)(nil), "flavortown.LineItem")
	proto.RegisterType((*Lunch)(nil), "flavortown.Lunch")
	proto.RegisterType((*Nothing)(nil), "flavortown.Nothing")
}
func (this *Menu) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Menu)
	if !ok {
		that2, ok := that.(Menu)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if !this.Items[i].Equal(that1.Items[i]) {
			return false
		}
	}
	return true
}
func (this *LineItem) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LineItem)
	if !ok {
		that2, ok := that.(LineItem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if that1.Dish == nil {
		if this.Dish != nil {
			return false
		}
	} else if this.Dish == nil {
		return false
	} else if !this.Dish.Equal(that1.Dish) {
		return false
	}
	if this.PriceCents != that1.PriceCents {
		return false
	}
	if !this.CreatedAt.Equal(that1.CreatedAt) {
		return false
	}
	if !this.UpdatedAt.Equal(that1.UpdatedAt) {
		return false
	}
	if !this.Nothing.Equal(that1.Nothing) {
		return false
	}
	if !this.Sides.Equal(that1.Sides) {
		return false
	}
	return true
}
func (this *LineItem_Lunch) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LineItem_Lunch)
	if !ok {
		that2, ok := that.(LineItem_Lunch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Lunch.Equal(that1.Lunch) {
		return false
	}
	return true
}
func (this *LineItem_TastyDessert) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LineItem_TastyDessert)
	if !ok {
		that2, ok := that.(LineItem_TastyDessert)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.TastyDessert.Equal(that1.TastyDessert) {
		return false
	}
	return true
}
func (this *Lunch) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Lunch)
	if !ok {
		that2, ok := that.(Lunch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !bytes.Equal(this.Description, that1.Description) {
		return false
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if this.Tags[i] != that1.Tags[i] {
			return false
		}
	}
	return true
}
func (this *Nothing) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Nothing)
	if !ok {
		that2, ok := that.(Nothing)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Void != that1.Void {
		return false
	}
	return true
}

type MenuGetter interface {
	GetMenu() *Menu
}

var GraphQLMenuType *github_com_graphql_go_graphql.Object

type LineItemGetter interface {
	GetLineItem() *LineItem
}

var GraphQLLineItemType *github_com_graphql_go_graphql.Object
var GraphQLLineItemDishUnion *github_com_graphql_go_graphql.Union

type LunchGetter interface {
	GetLunch() *Lunch
}

var GraphQLLunchType *github_com_graphql_go_graphql.Object
var GraphQLLunch_TagsEntryType = github_com_opsee_protobuf_plugin_graphql_scalars.Map

type NothingGetter interface {
	GetNothing() *Nothing
}

var GraphQLNothingType *github_com_graphql_go_graphql.Object

func (g *LineItem_Lunch) GetLunch() *Lunch {
	return g.Lunch
}
func (g *LineItem_TastyDessert) GetDessert() *flavortown_dessert.Dessert {
	return g.TastyDessert
}

func init() {
	GraphQLMenuType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "flavortownMenu",
		Description: "The menu at Guy’s American Kitchen & Bar reflects his signature style of authentic and surprising flavors",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"items": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.NewList(GraphQLLineItemType),
					Description: "These dishes are crafted with the heart and soul of hometown favorites and infused with Guy’s big, daring flavors",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Menu)
						if ok {
							return obj.Items, nil
						}
						inter, ok := p.Source.(MenuGetter)
						if ok {
							face := inter.GetMenu()
							if face == nil {
								return nil, nil
							}
							return face.Items, nil
						}
						return nil, fmt.Errorf("field items not resolved")
					},
				},
			}
		}),
	})
	GraphQLLineItemType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "flavortownLineItem",
		Description: "A line item representing a dish and price",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"price_cents": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.Int,
					Description: "The price of the dish in cents",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*LineItem)
						if ok {
							return obj.PriceCents, nil
						}
						inter, ok := p.Source.(LineItemGetter)
						if ok {
							face := inter.GetLineItem()
							if face == nil {
								return nil, nil
							}
							return face.PriceCents, nil
						}
						return nil, fmt.Errorf("field price_cents not resolved")
					},
				},
				"created_at": &github_com_graphql_go_graphql.Field{
					Type:        github_com_opsee_protobuf_plugin_graphql_scalars.Timestamp,
					Description: "A timestamp representing when the dish was added to the menu",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*LineItem)
						if ok {
							if obj.CreatedAt == nil {
								return nil, nil
							}
							return obj.GetCreatedAt(), nil
						}
						inter, ok := p.Source.(LineItemGetter)
						if ok {
							face := inter.GetLineItem()
							if face == nil {
								return nil, nil
							}
							if face.CreatedAt == nil {
								return nil, nil
							}
							return face.GetCreatedAt(), nil
						}
						return nil, fmt.Errorf("field created_at not resolved")
					},
				},
				"updated_at": &github_com_graphql_go_graphql.Field{
					Type:        github_com_opsee_protobuf_plugin_graphql_scalars.Timestamp,
					Description: "A timestamp representing when the dish was updated",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*LineItem)
						if ok {
							if obj.UpdatedAt == nil {
								return nil, nil
							}
							return obj.GetUpdatedAt(), nil
						}
						inter, ok := p.Source.(LineItemGetter)
						if ok {
							face := inter.GetLineItem()
							if face == nil {
								return nil, nil
							}
							if face.UpdatedAt == nil {
								return nil, nil
							}
							return face.GetUpdatedAt(), nil
						}
						return nil, fmt.Errorf("field updated_at not resolved")
					},
				},
				"nothing": &github_com_graphql_go_graphql.Field{
					Type:        GraphQLNothingType,
					Description: "A list of nothing really",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*LineItem)
						if ok {
							if obj.Nothing == nil {
								return nil, nil
							}
							return obj.GetNothing(), nil
						}
						inter, ok := p.Source.(LineItemGetter)
						if ok {
							face := inter.GetLineItem()
							if face == nil {
								return nil, nil
							}
							if face.Nothing == nil {
								return nil, nil
							}
							return face.GetNothing(), nil
						}
						return nil, fmt.Errorf("field nothing not resolved")
					},
				},
				"sides": &github_com_graphql_go_graphql.Field{
					Type:        github_com_opsee_protobuf_plugin_graphql_scalars.Permission,
					Description: "permission to eat?",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*LineItem)
						if ok {
							if obj.Sides == nil {
								return nil, nil
							}
							return obj.GetSides(), nil
						}
						inter, ok := p.Source.(LineItemGetter)
						if ok {
							face := inter.GetLineItem()
							if face == nil {
								return nil, nil
							}
							if face.Sides == nil {
								return nil, nil
							}
							return face.GetSides(), nil
						}
						return nil, fmt.Errorf("field sides not resolved")
					},
				},
				"dish": &github_com_graphql_go_graphql.Field{
					Type:        GraphQLLineItemDishUnion,
					Description: "The menu dish, can either be lunch or dessert",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*LineItem)
						if !ok {
							return nil, fmt.Errorf("field dish not resolved")
						}
						return obj.GetDish(), nil
					},
				},
			}
		}),
	})
	GraphQLLunchType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "flavortownLunch",
		Description: "A delicious lunch dish on the menu",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"name": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "The name of the dish",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Lunch)
						if ok {
							return obj.Name, nil
						}
						inter, ok := p.Source.(LunchGetter)
						if ok {
							face := inter.GetLunch()
							if face == nil {
								return nil, nil
							}
							return face.Name, nil
						}
						return nil, fmt.Errorf("field name not resolved")
					},
				},
				"description": &github_com_graphql_go_graphql.Field{
					Type:        github_com_opsee_protobuf_plugin_graphql_scalars.ByteString,
					Description: "The description of the dish",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Lunch)
						if ok {
							return obj.Description, nil
						}
						inter, ok := p.Source.(LunchGetter)
						if ok {
							face := inter.GetLunch()
							if face == nil {
								return nil, nil
							}
							return face.Description, nil
						}
						return nil, fmt.Errorf("field description not resolved")
					},
				},
				"tags": &github_com_graphql_go_graphql.Field{
					Type:        GraphQLLunch_TagsEntryType,
					Description: "a wild map. lunch tags? i guess",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Lunch)
						if ok {
							return obj.Tags, nil
						}
						inter, ok := p.Source.(LunchGetter)
						if ok {
							face := inter.GetLunch()
							if face == nil {
								return nil, nil
							}
							return face.Tags, nil
						}
						return nil, fmt.Errorf("field tags not resolved")
					},
				},
			}
		}),
	})
	GraphQLNothingType = github_com_graphql_go_graphql.NewObject(github_com_graphql_go_graphql.ObjectConfig{
		Name:        "flavortownNothing",
		Description: "confusion",
		Fields: (github_com_graphql_go_graphql.FieldsThunk)(func() github_com_graphql_go_graphql.Fields {
			return github_com_graphql_go_graphql.Fields{
				"void": &github_com_graphql_go_graphql.Field{
					Type:        github_com_graphql_go_graphql.String,
					Description: "the void",
					Resolve: func(p github_com_graphql_go_graphql.ResolveParams) (interface{}, error) {
						obj, ok := p.Source.(*Nothing)
						if ok {
							return obj.Void, nil
						}
						inter, ok := p.Source.(NothingGetter)
						if ok {
							face := inter.GetNothing()
							if face == nil {
								return nil, nil
							}
							return face.Void, nil
						}
						return nil, fmt.Errorf("field void not resolved")
					},
				},
			}
		}),
	})
	GraphQLLineItemDishUnion = github_com_graphql_go_graphql.NewUnion(github_com_graphql_go_graphql.UnionConfig{
		Name:        "LineItemDish",
		Description: "The menu dish, can either be lunch or dessert",
		Types: []*github_com_graphql_go_graphql.Object{
			GraphQLLunchType,
			flavortown_dessert.GraphQLDessertType,
		},
		ResolveType: func(value interface{}, info github_com_graphql_go_graphql.ResolveInfo) *github_com_graphql_go_graphql.Object {
			switch value.(type) {
			case *LineItem_Lunch:
				return GraphQLLunchType
			case *LineItem_TastyDessert:
				return flavortown_dessert.GraphQLDessertType
			}
			return nil
		},
	})
}
func (m *Menu) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Menu) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			data[i] = 0xa
			i++
			i = encodeVarintFlavortown(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *LineItem) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *LineItem) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PriceCents != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintFlavortown(data, i, uint64(m.PriceCents))
	}
	if m.CreatedAt != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintFlavortown(data, i, uint64(m.CreatedAt.Size()))
		n1, err := m.CreatedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.UpdatedAt != nil {
		data[i] = 0x22
		i++
		i = encodeVarintFlavortown(data, i, uint64(m.UpdatedAt.Size()))
		n2, err := m.UpdatedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Nothing != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintFlavortown(data, i, uint64(m.Nothing.Size()))
		n3, err := m.Nothing.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Sides != nil {
		data[i] = 0x32
		i++
		i = encodeVarintFlavortown(data, i, uint64(m.Sides.Size()))
		n4, err := m.Sides.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Dish != nil {
		nn5, err := m.Dish.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += nn5
	}
	return i, nil
}

func (m *LineItem_Lunch) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.Lunch != nil {
		data[i] = 0xa2
		i++
		data[i] = 0x6
		i++
		i = encodeVarintFlavortown(data, i, uint64(m.Lunch.Size()))
		n6, err := m.Lunch.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *LineItem_TastyDessert) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.TastyDessert != nil {
		data[i] = 0xaa
		i++
		data[i] = 0x6
		i++
		i = encodeVarintFlavortown(data, i, uint64(m.TastyDessert.Size()))
		n7, err := m.TastyDessert.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *Lunch) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Lunch) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintFlavortown(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Description) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintFlavortown(data, i, uint64(len(m.Description)))
		i += copy(data[i:], m.Description)
	}
	if len(m.Tags) > 0 {
		for k, _ := range m.Tags {
			data[i] = 0x1a
			i++
			v := m.Tags[k]
			mapSize := 1 + len(k) + sovFlavortown(uint64(len(k))) + 1 + len(v) + sovFlavortown(uint64(len(v)))
			i = encodeVarintFlavortown(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintFlavortown(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintFlavortown(data, i, uint64(len(v)))
			i += copy(data[i:], v)
		}
	}
	return i, nil
}

func (m *Nothing) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Nothing) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Void) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintFlavortown(data, i, uint64(len(m.Void)))
		i += copy(data[i:], m.Void)
	}
	return i, nil
}

func encodeFixed64Flavortown(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Flavortown(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintFlavortown(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedMenu(r randyFlavortown, easy bool) *Menu {
	this := &Menu{}
	if r.Intn(10) != 0 {
		v1 := r.Intn(5)
		this.Items = make([]*LineItem, v1)
		for i := 0; i < v1; i++ {
			this.Items[i] = NewPopulatedLineItem(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLineItem(r randyFlavortown, easy bool) *LineItem {
	this := &LineItem{}
	this.PriceCents = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.PriceCents *= -1
	}
	if r.Intn(10) != 0 {
		this.CreatedAt = opsee_types1.NewPopulatedTimestamp(r, easy)
	}
	if r.Intn(10) != 0 {
		this.UpdatedAt = opsee_types1.NewPopulatedTimestamp(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Nothing = NewPopulatedNothing(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Sides = opsee_types.NewPopulatedPermission(r, easy)
	}
	oneofNumber_Dish := []int32{100, 101}[r.Intn(2)]
	switch oneofNumber_Dish {
	case 100:
		this.Dish = NewPopulatedLineItem_Lunch(r, easy)
	case 101:
		this.Dish = NewPopulatedLineItem_TastyDessert(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLineItem_Lunch(r randyFlavortown, easy bool) *LineItem_Lunch {
	this := &LineItem_Lunch{}
	this.Lunch = NewPopulatedLunch(r, easy)
	return this
}
func NewPopulatedLineItem_TastyDessert(r randyFlavortown, easy bool) *LineItem_TastyDessert {
	this := &LineItem_TastyDessert{}
	this.TastyDessert = flavortown_dessert.NewPopulatedDessert(r, easy)
	return this
}
func NewPopulatedLunch(r randyFlavortown, easy bool) *Lunch {
	this := &Lunch{}
	this.Name = randStringFlavortown(r)
	v2 := r.Intn(100)
	this.Description = make([]byte, v2)
	for i := 0; i < v2; i++ {
		this.Description[i] = byte(r.Intn(256))
	}
	if r.Intn(10) != 0 {
		v3 := r.Intn(10)
		this.Tags = make(map[string]string)
		for i := 0; i < v3; i++ {
			this.Tags[randStringFlavortown(r)] = randStringFlavortown(r)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedNothing(r randyFlavortown, easy bool) *Nothing {
	this := &Nothing{}
	this.Void = randStringFlavortown(r)
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyFlavortown interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneFlavortown(r randyFlavortown) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringFlavortown(r randyFlavortown) string {
	v4 := r.Intn(100)
	tmps := make([]rune, v4)
	for i := 0; i < v4; i++ {
		tmps[i] = randUTF8RuneFlavortown(r)
	}
	return string(tmps)
}
func randUnrecognizedFlavortown(r randyFlavortown, maxFieldNumber int) (data []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		data = randFieldFlavortown(data, r, fieldNumber, wire)
	}
	return data
}
func randFieldFlavortown(data []byte, r randyFlavortown, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		data = encodeVarintPopulateFlavortown(data, uint64(key))
		v5 := r.Int63()
		if r.Intn(2) == 0 {
			v5 *= -1
		}
		data = encodeVarintPopulateFlavortown(data, uint64(v5))
	case 1:
		data = encodeVarintPopulateFlavortown(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		data = encodeVarintPopulateFlavortown(data, uint64(key))
		ll := r.Intn(100)
		data = encodeVarintPopulateFlavortown(data, uint64(ll))
		for j := 0; j < ll; j++ {
			data = append(data, byte(r.Intn(256)))
		}
	default:
		data = encodeVarintPopulateFlavortown(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return data
}
func encodeVarintPopulateFlavortown(data []byte, v uint64) []byte {
	for v >= 1<<7 {
		data = append(data, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	data = append(data, uint8(v))
	return data
}
func (m *Menu) Size() (n int) {
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovFlavortown(uint64(l))
		}
	}
	return n
}

func (m *LineItem) Size() (n int) {
	var l int
	_ = l
	if m.PriceCents != 0 {
		n += 1 + sovFlavortown(uint64(m.PriceCents))
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovFlavortown(uint64(l))
	}
	if m.UpdatedAt != nil {
		l = m.UpdatedAt.Size()
		n += 1 + l + sovFlavortown(uint64(l))
	}
	if m.Nothing != nil {
		l = m.Nothing.Size()
		n += 1 + l + sovFlavortown(uint64(l))
	}
	if m.Sides != nil {
		l = m.Sides.Size()
		n += 1 + l + sovFlavortown(uint64(l))
	}
	if m.Dish != nil {
		n += m.Dish.Size()
	}
	return n
}

func (m *LineItem_Lunch) Size() (n int) {
	var l int
	_ = l
	if m.Lunch != nil {
		l = m.Lunch.Size()
		n += 2 + l + sovFlavortown(uint64(l))
	}
	return n
}
func (m *LineItem_TastyDessert) Size() (n int) {
	var l int
	_ = l
	if m.TastyDessert != nil {
		l = m.TastyDessert.Size()
		n += 2 + l + sovFlavortown(uint64(l))
	}
	return n
}
func (m *Lunch) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFlavortown(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovFlavortown(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovFlavortown(uint64(len(k))) + 1 + len(v) + sovFlavortown(uint64(len(v)))
			n += mapEntrySize + 1 + sovFlavortown(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Nothing) Size() (n int) {
	var l int
	_ = l
	l = len(m.Void)
	if l > 0 {
		n += 1 + l + sovFlavortown(uint64(l))
	}
	return n
}

func sovFlavortown(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozFlavortown(x uint64) (n int) {
	return sovFlavortown(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Menu) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlavortown
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Menu: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Menu: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavortown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlavortown
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &LineItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlavortown(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlavortown
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LineItem) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlavortown
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LineItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LineItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceCents", wireType)
			}
			m.PriceCents = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavortown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.PriceCents |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavortown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlavortown
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &opsee_types1.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavortown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlavortown
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatedAt == nil {
				m.UpdatedAt = &opsee_types1.Timestamp{}
			}
			if err := m.UpdatedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nothing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavortown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlavortown
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Nothing == nil {
				m.Nothing = &Nothing{}
			}
			if err := m.Nothing.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sides", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavortown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlavortown
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sides == nil {
				m.Sides = &opsee_types.Permission{}
			}
			if err := m.Sides.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lunch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavortown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlavortown
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Lunch{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Dish = &LineItem_Lunch{v}
			iNdEx = postIndex
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TastyDessert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavortown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlavortown
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &flavortown_dessert.Dessert{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Dish = &LineItem_TastyDessert{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlavortown(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlavortown
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Lunch) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlavortown
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Lunch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Lunch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavortown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlavortown
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavortown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlavortown
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = append(m.Description[:0], data[iNdEx:postIndex]...)
			if m.Description == nil {
				m.Description = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavortown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlavortown
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavortown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavortown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthFlavortown
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavortown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapvalue uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavortown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapvalue |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapvalue := int(stringLenmapvalue)
			if intStringLenmapvalue < 0 {
				return ErrInvalidLengthFlavortown
			}
			postStringIndexmapvalue := iNdEx + intStringLenmapvalue
			if postStringIndexmapvalue > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := string(data[iNdEx:postStringIndexmapvalue])
			iNdEx = postStringIndexmapvalue
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlavortown(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlavortown
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Nothing) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlavortown
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Nothing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Nothing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Void", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlavortown
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlavortown
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Void = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlavortown(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlavortown
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFlavortown(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFlavortown
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFlavortown
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFlavortown
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthFlavortown
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowFlavortown
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipFlavortown(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthFlavortown = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFlavortown   = fmt.Errorf("proto: integer overflow")
)

var fileDescriptorFlavortown = []byte{
	// 509 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x94, 0x92, 0x4f, 0x6f, 0xd3, 0x30,
	0x18, 0xc6, 0x49, 0x9b, 0x74, 0xf4, 0xed, 0x90, 0x86, 0x99, 0x20, 0x2a, 0xb0, 0x55, 0x3d, 0x15,
	0xa4, 0x25, 0xa8, 0x08, 0x31, 0x4d, 0x5c, 0x28, 0x20, 0x81, 0x04, 0x08, 0x59, 0xbb, 0x57, 0x69,
	0xf2, 0x2e, 0xb5, 0x68, 0xec, 0x28, 0x76, 0x0a, 0xfd, 0x3a, 0x5c, 0xe0, 0x23, 0x70, 0xe4, 0xc8,
	0x91, 0x8f, 0x00, 0x7c, 0x00, 0xce, 0x1c, 0x71, 0xec, 0x64, 0xcb, 0x90, 0x40, 0x70, 0xb0, 0xf2,
	0xfe, 0x79, 0x7e, 0xf6, 0x9b, 0xc7, 0x86, 0x9d, 0x93, 0x55, 0xb4, 0x16, 0x85, 0x12, 0x6f, 0x78,
	0x90, 0x17, 0x42, 0x09, 0x02, 0x67, 0x95, 0xe1, 0x83, 0x94, 0xa9, 0x65, 0xb9, 0x08, 0x62, 0x91,
	0x85, 0x22, 0x97, 0x88, 0xa1, 0xd1, 0x2c, 0xca, 0x13, 0x9b, 0x9a, 0x2c, 0x54, 0x9b, 0x1c, 0x65,
	0x98, 0x63, 0x91, 0x31, 0x29, 0x99, 0xe0, 0xd2, 0xee, 0x34, 0x3c, 0xfa, 0x0f, 0x5a, 0xb1, 0x0c,
	0xa5, 0x8a, 0xb2, 0xbc, 0x66, 0x0f, 0x5a, 0x6c, 0x2a, 0x52, 0x71, 0x86, 0x56, 0x99, 0x25, 0xab,
	0xa8, 0x96, 0xdf, 0xf9, 0xa7, 0xa3, 0x4c, 0x58, 0x13, 0x87, 0x7f, 0x26, 0xf0, 0xad, 0x9e, 0x63,
	0xa5, 0x87, 0x4a, 0x50, 0x4a, 0x2c, 0x54, 0xf3, 0xb5, 0xe4, 0x78, 0x0a, 0xee, 0x0b, 0xe4, 0x25,
	0xb9, 0x0d, 0x1e, 0x53, 0x98, 0x49, 0xdf, 0x19, 0x75, 0x27, 0x83, 0xe9, 0x6e, 0xd0, 0xb2, 0xf2,
	0x39, 0xe3, 0xf8, 0x4c, 0x37, 0xa9, 0x95, 0x8c, 0x7f, 0x74, 0xe0, 0x62, 0x53, 0x23, 0xfb, 0x30,
	0xc8, 0x0b, 0x16, 0xe3, 0x3c, 0x46, 0xae, 0xa4, 0xdf, 0x19, 0x39, 0x13, 0x8f, 0x82, 0x29, 0x3d,
	0xaa, 0x2a, 0xe4, 0x1e, 0x40, 0x5c, 0x60, 0xa4, 0x30, 0x99, 0x47, 0xca, 0xef, 0xea, 0xfe, 0x60,
	0x7a, 0x35, 0xb0, 0xd3, 0x1b, 0xbb, 0x82, 0xe3, 0xc6, 0x2e, 0xda, 0xaf, 0x95, 0x0f, 0x55, 0x85,
	0x95, 0x79, 0xd2, 0x60, 0xee, 0xdf, 0xb1, 0x5a, 0xa9, 0xb1, 0x03, 0xd8, 0xe2, 0x42, 0x2d, 0x19,
	0x4f, 0x7d, 0xcf, 0x30, 0x57, 0xda, 0x7f, 0xf2, 0xd2, 0xb6, 0x68, 0xa3, 0xd1, 0x72, 0x4f, 0x32,
	0xed, 0x88, 0xdf, 0x33, 0xe2, 0x6b, 0xe7, 0x0e, 0x78, 0x75, 0xfa, 0x08, 0xa8, 0x55, 0x91, 0x5b,
	0xe0, 0xad, 0x4a, 0x1e, 0x2f, 0xfd, 0xc4, 0xc8, 0x2f, 0x9f, 0x73, 0xa9, 0x6a, 0x3c, 0xbd, 0x40,
	0xad, 0x82, 0xcc, 0xe0, 0x92, 0x8a, 0xa4, 0xda, 0xcc, 0x6b, 0xbf, 0x7d, 0x34, 0xc8, 0xf5, 0x36,
	0xd2, 0x5c, 0xc5, 0x63, 0xfb, 0xd5, 0xf0, 0xb6, 0x61, 0xea, 0x7c, 0xd6, 0x03, 0x37, 0x61, 0x72,
	0x39, 0x7e, 0xef, 0x80, 0x67, 0xb6, 0x27, 0x04, 0x5c, 0x1e, 0x65, 0xa8, 0x6f, 0xc9, 0x99, 0xf4,
	0xa9, 0x89, 0xc9, 0x08, 0x06, 0x7a, 0xa3, 0xb8, 0x60, 0xb9, 0xd2, 0xa3, 0x9a, 0x1b, 0xd8, 0xa6,
	0xed, 0x12, 0x09, 0xc1, 0x55, 0x51, 0x2a, 0xb5, 0xf9, 0xdd, 0xdf, 0x47, 0x30, 0xdb, 0x06, 0xc7,
	0xba, 0xfb, 0x84, 0xab, 0x62, 0x43, 0x8d, 0x70, 0x78, 0x1f, 0xfa, 0xa7, 0x25, 0xb2, 0x03, 0xdd,
	0xd7, 0xb8, 0xa9, 0x8f, 0xac, 0x42, 0xb2, 0x0b, 0xde, 0x3a, 0x5a, 0x95, 0x68, 0xce, 0xea, 0x53,
	0x9b, 0x1c, 0x75, 0x0e, 0x9d, 0xf1, 0x4d, 0xd8, 0xaa, 0x3d, 0xae, 0x46, 0x5d, 0x0b, 0x96, 0x34,
	0xa3, 0x56, 0xf1, 0xec, 0xc6, 0xcf, 0x6f, 0x7b, 0xce, 0x87, 0xef, 0x7b, 0xce, 0x47, 0xbd, 0x3e,
	0xeb, 0xf5, 0x45, 0xaf, 0xaf, 0x7a, 0x7d, 0x7a, 0xb7, 0xef, 0x2c, 0x7a, 0xe6, 0x49, 0xde, 0xfd,
	0x15, 0x00, 0x00, 0xff, 0xff, 0xe1, 0x0a, 0x18, 0xfb, 0xc7, 0x03, 0x00, 0x00,
}
